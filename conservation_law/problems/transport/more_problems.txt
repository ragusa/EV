    case 7:
    {                                                 // MMS-3
      Assert(dim == 1, ExcNotImplemented());          // assume 1-D
      Assert(is_time_dependent, ExcNotImplemented()); // assume not steady-state

      x_min = 0.0;
      x_max = 1.0;

      transport_direction[0] = 1.0;

      incoming_string = "0";

      cross_section_string = "1";

      exact_solution_option = ExactSolutionOption::parser;
      exact_solution_string = "exp(-t)*sin(pi*x)"; // assume omega_x = 1 and c = 1

      source_string =
        "-exp(-t)*sin(pi*x) + pi*exp(-t)*cos(pi*x) + exp(-t)*sin(pi*x)";
      source_time_dependent = true;

      initial_conditions_string = exact_solution_string;

      break;
    }
    case 8:
    {                                                 // source in left half
      Assert(dim == 1, ExcNotImplemented());          // assume 1-D
      Assert(is_time_dependent, ExcNotImplemented()); // assume not steady-state

      x_min = 0.0;
      x_max = 1.0;

      transport_direction[0] = 1.0;

      function_parser_constants["speed"] = 1.0;

      incoming_string = "0";
      function_parser_constants["incoming"] = 0.0;

      cross_section_string = "100";
      function_parser_constants["sigma"] = 100.0;

      source_time_dependent = false;
      source_string = "if (x<x_mid,10,0)";
      function_parser_constants["source"] = 10.0;

      exact_solution_option = ExactSolutionOption::parser;
      exact_solution_string = (std::string) "source/sigma*(1-exp(-sigma*" +
        "max(0,min(x,x_mid)-max(x-speed*t,0))))" +
        "*exp(-sigma*max(0,min(x,x_max)-max(x-speed*t,x_mid)))";

      initial_conditions_string = "0";

      break;
    }
    case 9:
    {                                        // MMS-4
      Assert(dim == 1, ExcNotImplemented()); // assume 1-D

      x_min = 0.0;
      x_max = 1.0;

      transport_direction[0] = 1.0;

      incoming_string = "0";

      cross_section_string = "sigma";
      function_parser_constants["sigma"] = 1.0;

      exact_solution_option = ExactSolutionOption::parser;
      if (is_time_dependent)
      {
        exact_solution_string = "x*t"; // assume omega_x = 1 and c = 1
        source_string = "x + t + sigma*x*t";
        source_time_dependent = true;
      }
      else
      {
        exact_solution_string = "x";
        source_string = "1 + sigma*x";
        source_time_dependent = false;
      }

      initial_conditions_string = exact_solution_string;

      break;
    }
    case 10:
    {                                        // MMS-5
      Assert(dim == 1, ExcNotImplemented()); // assume 1-D

      x_min = 0.0;
      x_max = 1.0;

      transport_direction[0] = 1.0;

      cross_section_string = "1";

      exact_solution_option = ExactSolutionOption::parser;

      if (is_time_dependent)
      {
        incoming_string = "t";
        exact_solution_string = "t"; // assume omega_x = 1 and c = 1
        source_string = "1 + t";
        source_time_dependent = true;
        initial_conditions_string = exact_solution_string;
      }
      else
      {
        incoming_string = "1";
        exact_solution_string = "1"; // assume omega_x = 1 and c = 1
        source_string = "1";
        source_time_dependent = false;
      }

      break;
    }
    case 11:
    { // skew void-to-absorber

      x_min = 0.0;
      x_max = 1.0;

      transport_direction[0] = 1.0 / sqrt(2.0);
      if (dim >= 2)
        transport_direction[1] = 1.0 / sqrt(3.0);
      if (dim >= 3)
        transport_direction[2] = 1.0 / sqrt(6.0);

      incoming_string = "1";
      function_parser_constants["incoming"] = 1.0;

      if (dim == 1) // 1-D
        cross_section_string = "if(x<x_mid, 0, sigma)";
      else if (dim == 2) // 2-D
        cross_section_string = "if(x>=x_mid, if(y>=x_mid, sigma, 0), 0)";
      else
        // 3-D
        cross_section_string = "if(x>=x_mid, if(y>=x_mid, if(z>=x_mid,"
                               "sigma, 0), 0), 0)";
      function_parser_constants["sigma"] = 10.0;

      source_time_dependent = false;
      source_string = "0";
      function_parser_constants["source"] = 0.0;

      // for now, assume no steady-state, but this would be easy to implement
      // by using the existing transient exact solution class and just using
      // t=large
      Assert(is_time_dependent, ExcNotImplemented());

      // create exact solution function constructor arguments
      const std::vector<double> interface_positions = {0.5};
      const std::vector<double> region_sources = {0.0, 0.0};
      const std::vector<double> region_sigmas = {0.0, 10.0};
      const std::vector<double> direction(
        {1.0 / sqrt(2.0), 1.0 / sqrt(3.0), 1.0 / sqrt(6.0)});
      const double incoming = 1.0;
      exact_solution_option = ExactSolutionOption::multi_region;

      // create MultiRegionExactSolution object
      std::shared_ptr<MultiRegionExactSolution<dim>>
        exact_solution_function_derived =
          std::make_shared<MultiRegionExactSolution<dim>>(interface_positions,
                                                          region_sources,
                                                          region_sigmas,
                                                          direction,
                                                          incoming);
      // point base class shared pointer to derived class function object
      exact_solution_function = exact_solution_function_derived;

      initial_conditions_string = "0";

      break;
    }
    case 12:
    { // 3-region

      // for now, assume 1-D
      Assert(dim == 1, ExcNotImplemented());

      x_min = 0.0;
      x_max = 1.0;

      transport_direction[0] = 1.0;

      incoming_string = "1";
      function_parser_constants["incoming"] = 1.0;

      cross_section_string = "if(x<=x1, sigma0, if(x<=x2, sigma1, sigma2))";
      function_parser_constants["sigma0"] = 1.0;
      function_parser_constants["sigma1"] = 40.0;
      function_parser_constants["sigma2"] = 20.0;
      function_parser_constants["x1"] = 0.3;
      function_parser_constants["x2"] = 0.6;

      source_time_dependent = false;
      source_string = "if(x<=x1, q0, if(x<=x2, q1, q2))";
      function_parser_constants["q0"] = 1.0;
      function_parser_constants["q1"] = 5.0;
      function_parser_constants["q2"] = 20.0;

      // create exact solution function constructor arguments
      const std::vector<double> interface_positions = {0.3, 0.6};
      const std::vector<double> region_sources = {1.0, 5.0, 20.0};
      const std::vector<double> region_sigmas = {1.0, 40.0, 20.0};
      const std::vector<double> direction({1.0, 0.0, 0.0});
      const double incoming = 1.0;
      exact_solution_option = ExactSolutionOption::multi_region;

      // create MultiRegionExactSolution object
      std::shared_ptr<MultiRegionExactSolution<dim>>
        exact_solution_function_derived =
          std::make_shared<MultiRegionExactSolution<dim>>(interface_positions,
                                                          region_sources,
                                                          region_sigmas,
                                                          direction,
                                                          incoming);
      // point base class shared pointer to derived class function object
      exact_solution_function = exact_solution_function_derived;

      // for now, assume no steady-state, but this would be easy to implement
      // by using the existing transient exact solution class and just using
      // t=large
      Assert(is_time_dependent, ExcNotImplemented());

      initial_conditions_string = "0";

      break;
    }
    case 13:
    { // source-in-void to absorber

      // create exact solution function constructor arguments
      const std::vector<double> interface_positions = {0.5};
      const std::vector<double> region_sources = {1.0, 0.0};
      const std::vector<double> region_sigmas = {0.0, 10.0};
      const std::vector<double> direction({1.0, 0.0, 0.0});
      const double incoming = 0.0;

      x_min = 0.0;
      x_max = 1.0;

      for (unsigned int d = 0; d < dim; ++d)
        transport_direction[d] = direction[d];

      incoming_string = "incoming";
      function_parser_constants["incoming"] = incoming;

      function_parser_constants["x1"] = interface_positions[0];

      function_parser_constants["sigma0"] = region_sigmas[0];
      function_parser_constants["sigma1"] = region_sigmas[1];

      source_time_dependent = false;
      function_parser_constants["q0"] = region_sources[0];
      function_parser_constants["q1"] = region_sources[1];

      if (dim == 1)
      {
        cross_section_string = "if(x<=x1, sigma0, sigma1)";
        source_string = "if(x<=x1, q0, q1)";
      }
      else if (dim == 2)
      {
        cross_section_string = "if(x<=x1 || y<=x1, sigma0, sigma1)";
        source_string = "if(x<=x1 || y<=x1, q0, q1)";
      }
      else
      {
        Assert(false, ExcNotImplemented());
      }

      // create MultiRegionExactSolution object
      if (is_time_dependent)
      {
        exact_solution_option = ExactSolutionOption::multi_region;

        std::shared_ptr<MultiRegionExactSolution<dim>>
          exact_solution_function_derived =
            std::make_shared<MultiRegionExactSolution<dim>>(interface_positions,
                                                            region_sources,
                                                            region_sigmas,
                                                            direction,
                                                            incoming);
        // point base class shared pointer to derived class function object
        exact_solution_function = exact_solution_function_derived;
      }
      else
      {
        exact_solution_option = ExactSolutionOption::parser;

        Assert(dim == 1, ExcNotImplemented());
        exact_solution_string = "if(x<0.5,x,0.5*exp(-10*(x-0.5)))";
      }

      initial_conditions_string = "0";

      break;
    }
    case 14:
    { // multi-region

      const std::vector<double> interface_positions = {0.2, 0.4, 0.6, 0.8};
      const std::vector<double> region_sources = {0.0, 0.0, 10.0, 10.0, 5.0};
      const std::vector<double> region_sigmas = {0.0, 10.0, 0.0, 10.0, 5.0};
      const std::vector<double> direction(
        {1.0 / sqrt(2.0), 1.0 / sqrt(3.0), 1.0 / sqrt(6.0)});
      const double incoming = 1.0;

      x_min = 0.0;
      x_max = 1.0;

      for (unsigned int d = 0; d < dim; ++d)
        transport_direction[d] = direction[d];

      incoming_string = "incoming";
      function_parser_constants["incoming"] = incoming;

      function_parser_constants["x1"] = interface_positions[0];
      function_parser_constants["x2"] = interface_positions[1];
      function_parser_constants["x3"] = interface_positions[2];
      function_parser_constants["x4"] = interface_positions[3];
      function_parser_constants["sigma0"] = region_sigmas[0];
      function_parser_constants["sigma1"] = region_sigmas[1];
      function_parser_constants["sigma2"] = region_sigmas[2];
      function_parser_constants["sigma3"] = region_sigmas[3];
      function_parser_constants["sigma4"] = region_sigmas[4];
      function_parser_constants["q0"] = region_sources[0];
      function_parser_constants["q1"] = region_sources[1];
      function_parser_constants["q2"] = region_sources[2];
      function_parser_constants["q3"] = region_sources[3];
      function_parser_constants["q4"] = region_sources[4];

      cross_section_string =
        "if(x<=x1 || y<=x1, sigma0, if(x<=x2 || y<=x2,"
        " sigma1, if(x<=x3 || y<=x3, sigma2, if(x<=x4 || y<=x4,"
        " sigma3, sigma4))))";

      source_time_dependent = false;
      source_string = "if(x<=x1 || y<=x1, q0, if(x<=x2 || y<=x2,"
                      " q1, if(x<=x3 || y<=x3, q2, if(x<=x4 || y<=x4,"
                      " q3, q4))))";

      // create exact solution function constructor arguments
      exact_solution_option = ExactSolutionOption::multi_region;

      // create MultiRegionExactSolution object
      std::shared_ptr<MultiRegionExactSolution<dim>>
        exact_solution_function_derived =
          std::make_shared<MultiRegionExactSolution<dim>>(interface_positions,
                                                          region_sources,
                                                          region_sigmas,
                                                          direction,
                                                          incoming);
      // point base class shared pointer to derived class function object
      exact_solution_function = exact_solution_function_derived;

      // for now, assume no steady-state, but this would be easy to implement
      // by using the existing transient exact solution class and just using
      // t=large
      Assert(is_time_dependent, ExcNotImplemented());

      initial_conditions_string = "0";

      break;
    }
    case 15:
    { // 2-region saturation

      Assert(dim == 1, ExcNotImplemented());

      const std::vector<double> interface_positions = {0.5};
      const std::vector<double> region_sources = {1.0, 1.0e5};
      const std::vector<double> region_sigmas = {1.0, 1.0e5};
      const std::vector<double> direction({1.0, 0.0, 0.0});
      const double incoming = 1.0;

      x_min = 0.0;
      x_max = 1.0;

      for (unsigned int d = 0; d < dim; ++d)
        transport_direction[d] = direction[d];

      incoming_string = "incoming";
      function_parser_constants["incoming"] = incoming;

      function_parser_constants["x1"] = interface_positions[0];
      function_parser_constants["sigma0"] = region_sigmas[0];
      function_parser_constants["sigma1"] = region_sigmas[1];
      function_parser_constants["q0"] = region_sources[0];
      function_parser_constants["q1"] = region_sources[1];

      cross_section_string = "if(x<=x1, sigma0, sigma1)";

      source_time_dependent = false;
      source_string = "if(x<=x1, q0, q1)";

      // create exact solution function constructor arguments
      exact_solution_option = ExactSolutionOption::multi_region;

      // create MultiRegionExactSolution object
      std::shared_ptr<MultiRegionExactSolution<dim>>
        exact_solution_function_derived =
          std::make_shared<MultiRegionExactSolution<dim>>(interface_positions,
                                                          region_sources,
                                                          region_sigmas,
                                                          direction,
                                                          incoming);
      // point base class shared pointer to derived class function object
      exact_solution_function = exact_solution_function_derived;

      // for now, assume no steady-state, but this would be easy to implement
      // by using the existing transient exact solution class and just using
      // t=large
      Assert(is_time_dependent, ExcNotImplemented());

      initial_conditions_string = "0";

      break;
    }
